/**
 * Beginning of main script.
 */
(function(){


var logo = get('#', 'logo'),
    images = get('tag', 'img'),
    tri = get('#', 'logo-holder'),
    body = get('tag', 'body'),
    topArrow = get('#', 'top-arrow'),
    svgSchematics = get('.', 'cross'),
    header = get('#', 'top'),
    equilateral = equilateral(65, [50, 50], logo),
    mail = "<a href='#contact'>j<span>8</span></a>" +
    "<a href='#contact'><img src='visuals/icons/location.png' />" +
    "</a>protonmail.<span>c</span>h<cite>00000000</cite>";

window.switchState = {};


(function(root) {
    var preferences = {

        linkScrollSpeed: 1350,
        fadeOutSpeed: 0.25,
        fadeInSpeed: 0.6,
        logoSize: 11,
        smoothScrollOptions: {

            // Scrolling Core
            frameRate: 150, // [Hz]
            animationTime: 400, // [ms]
            stepSize: 400, // [px]

            // Pulse (less tweakable)
            // ratio of "tail" to "acceleration"
            pulseAlgorithm: true,
            pulseScale: 4,
            pulseNormalize: 1,

            // Acceleration
            accelerationDelta: 20, // 20
            accelerationMax: 1, // 1

            // Keyboard Settings
            keyboardSupport: true, // option
            arrowScroll: 50, // [px]

            // Other
            touchpadSupport: true,
            fixedBackground: true,
            excluded: ''
        }
    };

    root.opt = preferences;
}(window));

/**
* html5shiv-printshiv.js
* @author Alexander Farkas
* @preserve HTML5 Shiv 3.7.3-pre | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
* @see  @link{https://github.com/afarkas/html5shiv}
*/
/**
* @preserve HTML5 Shiv 3.7.3 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
*/
;(function(window, document) {
/*jshint evil:true */
  /** version */
  var version = '3.7.3';

  /** Preset options */
  var options = window.html5 || {};

  /** Used to skip problem elements */
  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

  /** Not all elements can be cloned in IE **/
  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

  /** Detect whether the browser supports default html5 styles */
  var supportsHtml5Styles;

  /** Name of the expando, to work with multiple documents or to re-shiv one document */
  var expando = '_html5shiv';

  /** The id for the the documents expando */
  var expanID = 0;

  /** Cached data for each document */
  var expandoData = {};

  /** Detect whether the browser supports unknown elements */
  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
        supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
          // assign a false positive if unable to shiv
          (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      // assign a false positive if detection fails => unable to shiv
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a style sheet with the given CSS text and adds it to the document.
   * @private
   * @param {Document} ownerDocument The document.
   * @param {String} cssText The CSS text.
   * @returns {StyleSheet} The style element.
   */
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }

  /**
   * Returns the value of `html5.elements` as an array.
   * @private
   * @returns {Array} An array of shived element node names.
   */
  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }

  /**
   * Extends the built-in list of html5 elements
   * @memberOf html5
   * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
   * @param {Document} ownerDocument The context document.
   */
  function addElements(newElements, ownerDocument) {
    var elements = html5.elements;
    if(typeof elements != 'string'){
      elements = elements.join(' ');
    }
    if(typeof newElements != 'string'){
      newElements = newElements.join(' ');
    }
    html5.elements = elements +' '+ newElements;
    shivDocument(ownerDocument);
  }

    /**
   * Returns the data associated to the given document
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Object} An object of data.
   */
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }

  /**
   * returns a shived element for the given nodeName and document
   * @memberOf html5
   * @param {String} nodeName name of the element
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived element.
   */
  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    // Avoid adding some elements to fragments in IE < 9 because
    // * Attributes like `name` or `type` cannot be set/changed once an element
    //   is inserted into a document/fragment
    // * Link elements with `src` attributes that are inaccessible, as with
    //   a 403 response, will cause the tab/window to crash
    // * Script elements appended to fragments will execute when their `src`
    //   or `text` property is set
    return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
  }

  /**
   * returns a shived DocumentFragment for the given document
   * @memberOf html5
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived DocumentFragment.
   */
  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }

  /**
   * Shivs the `createElement` and `createDocumentFragment` methods of the document.
   * @private
   * @param {Document|DocumentFragment} ownerDocument The document.
   * @param {Object} data of the document.
   */
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
      //abort shiv
      if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
        // unroll the `createElement` calls
        getElements().join().replace(/[\w\-:]+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
        // corrects block display not defined in IE6/7/8/9
        'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
        // adds styling not present in IE6/7/8/9
        'mark{background:#FF0;color:#000}' +
        // hides non-rendered elements
        'template{display:none}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The `html5` object is exposed so that more elements can be shived and
   * existing shiving can be detected on iframes.
   * @type Object
   * @example
   *
   * // options can be changed before the script is included
   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
   */
  var html5 = {

    /**
     * An array or space separated string of node names of the elements to shiv.
     * @memberOf html5
     * @type Array|String
     */
    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',

    /**
     * current version of html5shiv
     */
    'version': version,

    /**
     * A flag to indicate that the HTML5 style sheet should be inserted.
     * @memberOf html5
     * @type Boolean
     */
    'shivCSS': (options.shivCSS !== false),

    /**
     * Is equal to true if a browser supports creating unknown/HTML5 elements
     * @memberOf html5
     * @type boolean
     */
    'supportsUnknownElements': supportsUnknownElements,

    /**
     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
     * methods should be overwritten.
     * @memberOf html5
     * @type Boolean
     */
    'shivMethods': (options.shivMethods !== false),

    /**
     * A string to describe the type of `html5` object ("default" or "default print").
     * @memberOf html5
     * @type String
     */
    'type': 'default',

    // shivs the document according to the specified `html5` object options
    'shivDocument': shivDocument,

    //creates a shived element
    createElement: createElement,

    //creates a shived documentFragment
    createDocumentFragment: createDocumentFragment,

    //extends list of elements
    addElements: addElements
  };

  /*--------------------------------------------------------------------------*/

  // expose html5
  window.html5 = html5;

  // shiv the document
  shivDocument(document);

  /*------------------------------- Print Shiv -------------------------------*/

  /** Used to filter media types */
  var reMedia = /^$|\b(?:all|print)\b/;

  /** Used to namespace printable elements */
  var shivNamespace = 'html5shiv';

  /** Detect whether the browser supports shivable style sheets */
  var supportsShivableSheets = !supportsUnknownElements && (function() {
    // assign a false negative if unable to shiv
    var docEl = document.documentElement;
    return !(
      typeof document.namespaces == 'undefined' ||
      typeof document.parentWindow == 'undefined' ||
      typeof docEl.applyElement == 'undefined' ||
      typeof docEl.removeNode == 'undefined' ||
      typeof window.attachEvent == 'undefined'
    );
  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Wraps all HTML5 elements in the given document with printable elements.
   * (eg. the "header" element is wrapped with the "html5shiv:header" element)
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Array} An array wrappers added.
   */
  function addWrappers(ownerDocument) {
    var node,
        nodes = ownerDocument.getElementsByTagName('*'),
        index = nodes.length,
        reElements = RegExp('^(?:' + getElements().join('|') + ')$', 'i'),
        result = [];

    while (index--) {
      node = nodes[index];
      if (reElements.test(node.nodeName)) {
        result.push(node.applyElement(createWrapper(node)));
      }
    }
    return result;
  }

  /**
   * Creates a printable wrapper for the given element.
   * @private
   * @param {Element} element The element.
   * @returns {Element} The wrapper.
   */
  function createWrapper(element) {
    var node,
        nodes = element.attributes,
        index = nodes.length,
        wrapper = element.ownerDocument.createElement(shivNamespace + ':' + element.nodeName);

    // copy element attributes to the wrapper
    while (index--) {
      node = nodes[index];
      node.specified && wrapper.setAttribute(node.nodeName, node.nodeValue);
    }
    // copy element styles to the wrapper
    wrapper.style.cssText = element.style.cssText;
    return wrapper;
  }

  /**
   * Shivs the given CSS text.
   * (eg. header{} becomes html5shiv\:header{})
   * @private
   * @param {String} cssText The CSS text to shiv.
   * @returns {String} The shived CSS text.
   */
  function shivCssText(cssText) {
    var pair,
        parts = cssText.split('{'),
        index = parts.length,
        reElements = RegExp('(^|[\\s,>+~])(' + getElements().join('|') + ')(?=[[\\s,>+~#.:]|$)', 'gi'),
        replacement = '$1' + shivNamespace + '\\:$2';

    while (index--) {
      pair = parts[index] = parts[index].split('}');
      pair[pair.length - 1] = pair[pair.length - 1].replace(reElements, replacement);
      parts[index] = pair.join('}');
    }
    return parts.join('{');
  }

  /**
   * Removes the given wrappers, leaving the original elements.
   * @private
   * @params {Array} wrappers An array of printable wrappers.
   */
  function removeWrappers(wrappers) {
    var index = wrappers.length;
    while (index--) {
      wrappers[index].removeNode();
    }
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document for print.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivPrint(ownerDocument) {
    var shivedSheet,
        wrappers,
        data = getExpandoData(ownerDocument),
        namespaces = ownerDocument.namespaces,
        ownerWindow = ownerDocument.parentWindow;

    if (!supportsShivableSheets || ownerDocument.printShived) {
      return ownerDocument;
    }
    if (typeof namespaces[shivNamespace] == 'undefined') {
      namespaces.add(shivNamespace);
    }

    function removeSheet() {
      clearTimeout(data._removeSheetTimer);
      if (shivedSheet) {
          shivedSheet.removeNode(true);
      }
      shivedSheet= null;
    }

    ownerWindow.attachEvent('onbeforeprint', function() {

      removeSheet();

      var imports,
          length,
          sheet,
          collection = ownerDocument.styleSheets,
          cssText = [],
          index = collection.length,
          sheets = Array(index);

      // convert styleSheets collection to an array
      while (index--) {
        sheets[index] = collection[index];
      }
      // concat all style sheet CSS text
      while ((sheet = sheets.pop())) {
        // IE does not enforce a same origin policy for external style sheets...
        // but has trouble with some dynamically created stylesheets
        if (!sheet.disabled && reMedia.test(sheet.media)) {

          try {
            imports = sheet.imports;
            length = imports.length;
          } catch(er){
            length = 0;
          }

          for (index = 0; index < length; index++) {
            sheets.push(imports[index]);
          }

          try {
            cssText.push(sheet.cssText);
          } catch(er){}
        }
      }

      // wrap all HTML5 elements with printable elements and add the shived style sheet
      cssText = shivCssText(cssText.reverse().join(''));
      wrappers = addWrappers(ownerDocument);
      shivedSheet = addStyleSheet(ownerDocument, cssText);

    });

    ownerWindow.attachEvent('onafterprint', function() {
      // remove wrappers, leaving the original elements, and remove the shived style sheet
      removeWrappers(wrappers);
      clearTimeout(data._removeSheetTimer);
      data._removeSheetTimer = setTimeout(removeSheet, 500);
    });

    ownerDocument.printShived = true;
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  // expose API
  html5.type += ' print';
  html5.shivPrint = shivPrint;

  // shiv for print
  shivPrint(document);

  if(typeof module == 'object' && module.exports){
    module.exports = html5;
  }

}(typeof window !== "undefined" ? window : this, document));

/**
 *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for
 *   optimal cross-browser development.
 *    Version:  v1.0.2
 *     License:  MIT
 *      Copyright Julien Etienne 2015 All Rights Reserved.
 *        github:  https://github.com/julienetie/request-frame
 *‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
 */
(function (window) {

/**
 * @param  {String} type - request | cancel | native.
 * @return {Function} Timing function.
 */
function requestFrame(type) {
    // The only vendor prefixes required.
    var vendors = ['moz', 'webkit'],

        // Disassembled timing function abbreviations.
        aF = 'AnimationFrame',
        rqAF = 'Request' + aF,

        // Final assigned functions.
        assignedRequestAnimationFrame,
        assignedCancelAnimationFrame,

        // Initial time of the timing lapse.
        previousTime = 0,

        mozRAF = window.mozRequestAnimationFrame,
        mozCAF = window.mozCancelAnimationFrame,

        // Checks for firefox 4 - 10 function pair mismatch.
        hasMozMismatch = mozRAF && !mozCAF,

        func;

    // Date.now polyfill, mainly for legacy IE versions.
    if (!Date.now) {
        Date.now = function() {
            return new Date().getTime();
        };
    }

    /**
     * hasIOS6RequestAnimationFrameBug.
     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}
     * - for Commentary.
     * @Copyright 2015 - Julien Etienne. 
     * @License: MIT.
     */
    function hasIOS6RequestAnimationFrameBug() {
        var webkitRAF = window.webkitRequestAnimationFrame,
            rAF = window.requestAnimationFrame,

            // CSS/ Device with max for iOS6 Devices.
            hasMobileDeviceWidth = screen.width <= 768 ? true : false,

            // Only supports webkit prefixed requestAnimtionFrane.
            requiresWebkitprefix = !(webkitRAF && rAF),

            // iOS6 webkit browsers don't support performance now.
            hasNoNavigationTiming = window.performance ? false : true,

            iOS6Notice = 'setTimeout is being used as a substitiue for' +
            'requestAnimationFrame due to a bug within iOS 6 builds',

            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&
            hasNoNavigationTiming;

        function bugCheckresults(timingFnA, timingFnB, notice) {
            if (timingFnA || timingFnB) {
                console.warn(notice);
                return true;
            } else {
                return false;
            }
        }

        function displayResults() {
            if (hasIOS6Bug) {
                return bugCheckresults(webkitRAF, rAF, iOS6Notice);
            } else {
                return false;
            }
        }

        return displayResults();
    }

    /**
     * Native clearTimeout function.
     * @return {Function}
     */
    function clearTimeoutWithId(id) {
        clearTimeout(id);
    }

    /**
     * Based on a polyfill by Erik, introduced by Paul Irish & 
     * further improved by Darius Bacon.
     * @see  {@link http://www.paulirish.com/2011/
     * requestanimationframe-for-smart-animating}
     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/
     * master/requestAnimationFrame.js}
     * @callback {Number} Timestamp.
     * @return {Function} setTimeout Function.
     */
    function setTimeoutWithTimestamp(callback) {
        var immediateTime = Date.now(),
            lapsedTime = Math.max(previousTime + 16, immediateTime);
        return setTimeout(function() {
                callback(previousTime = lapsedTime);
            },
            lapsedTime - immediateTime);
    }

    /**
     * Queries the native function, prefixed function 
     * or use the setTimeoutWithTimestamp function.
     * @return {Function}
     */
    function queryRequestAnimationFrame() {
        if (Array.prototype.filter) {
            assignedRequestAnimationFrame = window['request' + aF] ||
                window[vendors.filter(function(vendor) {
                    if (window[vendor + rqAF] !== undefined)
                        return vendor;
                }) + rqAF] || setTimeoutWithTimestamp;
        } else {
            return setTimeoutWithTimestamp;
        }
        if (!hasIOS6RequestAnimationFrameBug()) {
            return assignedRequestAnimationFrame;
        } else {
            return setTimeoutWithTimestamp;
        }
    }

    /**
     * Queries the native function, prefixed function 
     * or use the clearTimeoutWithId function.
     * @return {Function}
     */
    function queryCancelAnimationFrame() {
        var cancellationNames = [];
        if (Array.prototype.map) {
            vendors.map(function(vendor) {
                return ['Cancel', 'CancelRequest'].map(
                    function(cancellationNamePrefix) {
                        cancellationNames.push(vendor +
                            cancellationNamePrefix + aF);
                    });
            });
        } else {
            return clearTimeoutWithId;
        }

        /**
         * Checks for the prefixed cancelAnimationFrame implementation.
         * @param  {Array} prefixedNames - An array of the prefixed names. 
         * @param  {Number} i - Iteration start point.
         * @return {Function} prefixed cancelAnimationFrame function.
         */
        function prefixedCancelAnimationFrame(prefixedNames, i) {
            var cancellationFunction;
            for (; i < prefixedNames.length; i++) {
                if (window[prefixedNames[i]]) {
                    cancellationFunction = window[prefixedNames[i]];
                    break;
                }
            }
            return cancellationFunction;
        }

        // Use truthly function
        assignedCancelAnimationFrame = window['cancel' + aF] ||
            prefixedCancelAnimationFrame(cancellationNames, 0) ||
            clearTimeoutWithId;

        // Check for iOS 6 bug
        if (!hasIOS6RequestAnimationFrameBug()) {
            return assignedCancelAnimationFrame;
        } else {
            return clearTimeoutWithId;
        }
    }

    function getRequestFn() {
        if (hasMozMismatch) {
            return setTimeoutWithTimestamp;
        } else {
            return queryRequestAnimationFrame();
        }
    }

    function getCancelFn() {
        return queryCancelAnimationFrame();
    }

    function setNativeFn() {
        if (hasMozMismatch) {
            window.requestAnimationFrame = setTimeoutWithTimestamp;
            window.cancelAnimationFrame = clearTimeoutWithId;
        } else {
            window.requestAnimationFrame = queryRequestAnimationFrame();
            window.cancelAnimationFrame = queryCancelAnimationFrame();
        }
    }

    /**
     * The type value "request" singles out firefox 4 - 10 and 
     * assigns the setTimeout function if plausible.
     */

    switch (type) {
        case 'request':
        case '':
            func = getRequestFn();
            break;

        case 'cancel':
            func = getCancelFn();
            break;

        case 'native':
            setNativeFn();
            break;
        default:
            throw new Error('RequestFrame parameter is not a type.');
    }
    return func;
}


// Node.js/ CommonJS
if (typeof module === 'object' && typeof module.exports === 'object') {
module.exports = exports = requestFrame;
}

// AMD
else if (typeof define === 'function' && define.amd) {
define(function() {
  return requestFrame;
});
}

// Default to window as global
else if (typeof window === 'object') {
window.requestFrame = requestFrame;
}
/* global -module, -exports, -define */

}(window));

// Initialize
requestFrame('native');

/*           _.-~-.
           7''  Q..\
        _7         (_
      _7  _/    _q.  /
    _7 . ___  /VVvv-'_                                            .
   7/ / /~- \_\\      '-._     .-'                      /       //
  ./ ( /-~-/  ||'=.__  '::. '-~'' {             ___   /  //     ./{
 V   V-~-~|   ||   __''_   ':::.   ''~-~.___.-'' _/  // / {_   /  {  /
  VV/-~-~-|  / \ .'__'. '.  '::  ____               _ _ _        ''.
  / /~~~~||  VVV/ /  \ )  \     |  _ \ ___  ___(_)___(_) | | __ _   .::'
 / (~-~-~\\.-' /    \'   \::::. | |_) / _ \/ __| |_  / | | |/ _` | :::'
/..\    /..\__/      '     '::: |  _ <  __/\__ \ |/ /| | | | (_| | ::'
vVVv    vVVv                 ': |_| \_\___||___/_/___|_|_|_|\__,_| ''v0.3
Copyright (c) 2015 Julien Etienne. MIT License */

(function(root) {

    var previousTime = 0, i;

    function dateNow() {
        return Date.now() || new Date().getTime();
    }

    var request = requestAnimationFrame,
        cancel = cancelAnimationFrame;

    var requestTimeout = function(fn, delay) {
        var start = dateNow();

        function increment(d) {
            this.k = !this.k ? d : null;
            return this.k += 1;
        }

        function loop() {
            this.delta = dateNow() - start;
            // **Lint**
            this.callHandler = this.delta >= delay ? fn.call() : request(loop);
        }

        request(loop);
        return increment(0);
    };


    root.resizilla = function(handler, delay, inception) {

        function debounce() {
            var timeout;

            return function() {
                var context = this,
                    args = arguments;

                var lastCall = function() {
                    timeout = 0;
                    if (!inception) {
                        handler.apply(context, args);
                    }
                };

                this.instant = inception && !timeout;
                cancel(timeout);
                timeout = requestTimeout(lastCall, delay);

                if (this.instant) {
                    handler.apply(context, args);
                }
            };
        }

        var handlerFunc = debounce(arguments),

            addEvent = function(handler) {
                if (this.addEventListener)
                    this.addEventListener('resize', handler, true);
                else
                    this.attachEvent('onresize', handler);
            };

        if (screen.width > 1023 || this.mobile) {
            addEvent.call(this, handlerFunc);
        }
    };

    resizilla.enableMobileResize = function() {
        root.mobile = true;
    };

}(window));
//.call(this));

/*!
 * clicktap - v0.0.3
 *
 * Copyright (c) 2014, @pazguille <guille87paz@gmail.com>
 * Released under the MIT license.
 */
(function(window) {
'use strict';

/**
 * Privates
 */
var doc = window.document,
    msPointerSupported = window.navigator.msPointerEnabled,
    touch = {
      'start': msPointerSupported ? 'MSPointerDown' : 'touchstart',
      'move': msPointerSupported ? 'MSPointerMove' : 'touchmove',
      'end': msPointerSupported ? 'MSPointerUp' : 'touchend'
    },
    pointerCanceled = false;

/**
 * Adds touch events if browser supports it
 */
if ('createTouch' in doc) {
  doc.addEventListener(touch.start, function() { pointerCanceled = false; }, false);
  doc.addEventListener(touch.move, function() { pointerCanceled = true; }, false);
}

/**
 * Adds a listener to the collection for a specified event.
 * @public
 * @function
 * @name clicktap#on
 * @param {String} el - DOM element.
 * @param {Function} listener - Listener function.
 * @param {Boolean} [capture] - Indicate if use capture path.
 * @example
 * var startDoingStuff = function (event, param1, param2, ...) {
 *   // Some code here!
 * };
 *
 * clicktap(document, startDoingStuff, false);
 */
function clicktap(el, listener, capture) {

  function fn(eve) {
    if (pointerCanceled) { pointerCanceled = false; return; }
    listener.call(el, eve);
  //  eve.preventDefault();
  }

  listener.fn = fn;

  el.addEventListener(touch.end, listener.fn, capture || false);
  el.addEventListener('click', listener.fn, capture || false);

  return clicktap;
}

/**
 * Adds a listener to a given HTMLElement on click/tap event.
 * @public
 * @function
 * @param {String} el - DOM element.
 * @param {Function} listener - Listener function.
 * @param {Boolean} [capture] - Indicate if use capture path.
 * @example
 * var startDoingStuff = function (event, param1, param2, ...) {
 *   // Some code here!
 * };
 *
 * clicktap.on(document, startDoingStuff);
 */
clicktap.on = clicktap;

/**
 * Removes a listener from a given HTMLElement.
 * @public
 * @function
 * @param {String} el - DOM element.
 * @param {Function} listener = Listener function.
 * @returns itself
 * @example
 * clicktap.off(document, startDoingStuff);
 */
clicktap.off = function(el, listener) {
  el.removeEventListener(touch.end, listener.fn);
  el.removeEventListener('click', listener.fn);
  return clicktap;
};

/**
 * Expose clicktap
 */
// AMD
if (typeof window.define === 'function' && window.define.amd !== undefined) {
  window.define('clicktap', [], function () {
    return clicktap;
  });
// CommonJS
} else if (typeof module !== 'undefined' && module.exports !== undefined) {
  module.exports = clicktap;
// Browser
} else {
  window.clicktap = clicktap;
}

}(this));

/**
 * SmoothScroll
 * @author Balazs Galambosi
 * @version 1.3.8
 * @license  MIT
 * @see  @link {https://gist.github.com/galambalazs/6477177}
 */

(function (globalOptions) {
  
// Scroll Variables (tweakable)
var options = globalOptions.smoothScrollOptions;

// Other Variables
var isExcluded = false;
var isFrame = false;
var direction = { x: 0, y: 0 };
var initDone  = false;
var root = document.documentElement;
var activeElement;
var observer;
var deltaBuffer = [];
var isMac = /^Mac/.test(navigator.platform);
 
var key = { left: 37, up: 38, right: 39, down: 40, spacebar: 32, 
            pageup: 33, pagedown: 34, end: 35, home: 36 };
 
 
/***********************************************
 * INITIALIZE
 ***********************************************/
 
/**
 * Tests if smooth scrolling is allowed. Shuts down everything if not.
 */
function initTest() {
    if (options.keyboardSupport) {
        addEvent('keydown', keydown);
    }
}
 
/**
 * Sets up scrolls array, determines if frames are involved.
 */
function init() {
  
    if (initDone || !document.body) return;
 
    initDone = true;
 
    var body = document.body;
    var html = document.documentElement;
    var windowHeight = window.innerHeight; 
    var scrollHeight = body.scrollHeight;
    
    // check compat mode for root element
    root = (document.compatMode.indexOf('CSS') >= 0) ? html : body;
    activeElement = body;
    
    initTest();
 
    // Checks if this script is running in a frame
    if (top != self) {
        isFrame = true;
    }
 
    /**
     * This fixes a bug where the areas left and right to 
     * the content does not trigger the onmousewheel event
     * on some pages. e.g.: html, body { height: 100% }
     */
    else if (scrollHeight > windowHeight &&
            (body.offsetHeight <= windowHeight || 
             html.offsetHeight <= windowHeight)) {
 
        var fullPageElem = document.createElement('div');
        fullPageElem.style.cssText = 'position:absolute; z-index:-10000; ' +
                                     'top:0; left:0; right:0; height:' + 
                                      root.scrollHeight + 'px';
        document.body.appendChild(fullPageElem);
        
        // DOM changed (throttled) to fix height
        var pendingRefresh;
        var refresh = function () {
            if (pendingRefresh) return; // could also be: clearTimeout(pendingRefresh);
            pendingRefresh = setTimeout(function () {
                if (isExcluded) return; // could be running after cleanup
                fullPageElem.style.height = '0';
                fullPageElem.style.height = root.scrollHeight + 'px';
                pendingRefresh = null;
            }, 500); // act rarely to stay fast
        };
  
        setTimeout(refresh, 10);
 
        // TODO: attributeFilter?
        var config = {
            attributes: true, 
            childList: true, 
            characterData: false 
            // subtree: true
        };
 
        observer = new MutationObserver(refresh);
        observer.observe(body, config);
 
        if (root.offsetHeight <= windowHeight) {
            var clearfix = document.createElement('div');   
            clearfix.style.clear = 'both';
            body.appendChild(clearfix);
        }
    }
 
    // disable fixed background
    if (!options.fixedBackground && !isExcluded) {
        body.style.backgroundAttachment = 'scroll';
        html.style.backgroundAttachment = 'scroll';
    }
}
 
/**
 * Removes event listeners and other traces left on the page.
 */
function cleanup() {
    observer && observer.disconnect();
    removeEvent(wheelEvent, wheel);
    removeEvent('mousedown', mousedown);
    removeEvent('keydown', keydown);
}
 
 
/************************************************
 * SCROLLING 
 ************************************************/
 
var que = [];
var pending = false;
var lastScroll = Date.now();
 
/**
 * Pushes scroll actions to the scrolling queue.
 */
function scrollArray(elem, left, top) {
    
    directionCheck(left, top);
 
    if (options.accelerationMax != 1) {
        var now = Date.now();
        var elapsed = now - lastScroll;
        if (elapsed < options.accelerationDelta) {
            var factor = (1 + (50 / elapsed)) / 2;
            if (factor > 1) {
                factor = Math.min(factor, options.accelerationMax);
                left *= factor;
                top  *= factor;
            }
        }
        lastScroll = Date.now();
    }          
    
    // push a scroll command
    que.push({
        x: left, 
        y: top, 
        lastX: (left < 0) ? 0.99 : -0.99,
        lastY: (top  < 0) ? 0.99 : -0.99, 
        start: Date.now()
    });
        
    // don't act if there's a pending queue
    if (pending) {
        return;
    }  
 
    var scrollWindow = (elem === document.body);
    
    var step = function (time) {
        
        var now = Date.now();
        var scrollX = 0;
        var scrollY = 0; 
    
        for (var i = 0; i < que.length; i++) {
            
            var item = que[i];
            var elapsed  = now - item.start;
            var finished = (elapsed >= options.animationTime);
            
            // scroll position: [0, 1]
            var position = (finished) ? 1 : elapsed / options.animationTime;
            
            // easing [optional]
            if (options.pulseAlgorithm) {
                position = pulse(position);
            }
            
            // only need the difference
            var x = (item.x * position - item.lastX) >> 0;
            var y = (item.y * position - item.lastY) >> 0;
            
            // add this to the total scrolling
            scrollX += x;
            scrollY += y;            
            
            // update last values
            item.lastX += x;
            item.lastY += y;
        
            // delete and step back if it's over
            if (finished) {
                que.splice(i, 1); i--;
            }           
        }
 
        // scroll left and top
        if (scrollWindow) {
            window.scrollBy(scrollX, scrollY);
        } 
        else {
            if (scrollX) elem.scrollLeft += scrollX;
            if (scrollY) elem.scrollTop  += scrollY;                    
        }
        
        // clean up if there's nothing left to do
        if (!left && !top) {
            que = [];
        }
        
        if (que.length) { 
            requestFrameSmoothScroll(step, elem, (1000 / options.frameRate + 1)); 
        } else { 
            pending = false;
        }
    };
    
    // start a new queue of actions
    requestFrameSmoothScroll(step, elem, 0);
    pending = true;
}
 
 
/***********************************************
 * EVENTS
 ***********************************************/
 
/**
 * Mouse wheel handler.
 * @param {Object} event
 */
function wheel(event) {
 
    if (!initDone) {
        init();
    }
    
    var target = event.target;
    var overflowing = overflowingAncestor(target);
 
    // use default if there's no overflowing
    // element or default action is prevented   
    // or it's a zooming event with CTRL 
    if (!overflowing || event.defaultPrevented || event.ctrlKey) {
        return true;
    }
    
    // leave embedded content alone (flash & pdf)
    if (isNodeName(activeElement, 'embed') || 
       (isNodeName(target, 'embed') && /\.pdf/i.test(target.src)) ||
       isNodeName(activeElement, 'object')) {
        return true;
    }
 
    var deltaX = -event.wheelDeltaX || event.deltaX || 0;
    var deltaY = -event.wheelDeltaY || event.deltaY || 0;
    
    if (isMac) {
        if (event.wheelDeltaX && isDivisible(event.wheelDeltaX, 120)) {
            deltaX = -120 * (event.wheelDeltaX / Math.abs(event.wheelDeltaX));
        }
        if (event.wheelDeltaY && isDivisible(event.wheelDeltaY, 120)) {
            deltaY = -120 * (event.wheelDeltaY / Math.abs(event.wheelDeltaY));
        }
    }
    
    // use wheelDelta if deltaX/Y is not available
    if (!deltaX && !deltaY) {
        deltaY = -event.wheelDelta || 0;
    }
 
    // line based scrolling (Firefox mostly)
    if (event.deltaMode === 1) {
        deltaX *= 40;
        deltaY *= 40;
    }
    
    // check if it's a touchpad scroll that should be ignored
    if (!options.touchpadSupport && isTouchpad(deltaY)) {
        return true;
    }
 
    // scale by step size
    // delta is 120 most of the time
    // synaptics seems to send 1 sometimes
    if (Math.abs(deltaX) > 1.2) {
        deltaX *= options.stepSize / 120;
    }
    if (Math.abs(deltaY) > 1.2) {
        deltaY *= options.stepSize / 120;
    }
    
    scrollArray(overflowing, deltaX, deltaY);
    event.preventDefault();
    scheduleClearCache();
}
 
/**
 * Keydown event handler.
 * @param {Object} event
 */
function keydown(event) {
 
    var target   = event.target;
    var modifier = event.ctrlKey || event.altKey || event.metaKey || 
                  (event.shiftKey && event.keyCode !== key.spacebar);
    
    // our own tracked active element could've been removed from the DOM
    if (!document.contains(activeElement)) {
        activeElement = document.activeElement;
    }
 
    // do nothing if user is editing text
    // or using a modifier key (except shift)
    // or in a dropdown
    // or inside interactive elements
    var inputNodeNames = /^(textarea|select|embed|object)$/i;
    var buttonTypes = /^(button|submit|radio|checkbox|file|color|image)$/i;
    if ( inputNodeNames.test(target.nodeName) ||
         isNodeName(target, 'input') && !buttonTypes.test(target.type) ||
         isNodeName(activeElement, 'video') ||
         isInsideYoutubeVideo(event) ||
         target.isContentEditable || 
         event.defaultPrevented   ||
         modifier ) {
      return true;
    }
    
    // spacebar should trigger button press
    if ((isNodeName(target, 'button') ||
         isNodeName(target, 'input') && buttonTypes.test(target.type)) &&
        event.keyCode === key.spacebar) {
      return true;
    }
    
    var shift, x = 0, y = 0;
    var elem = overflowingAncestor(activeElement);
    var clientHeight = elem.clientHeight;
 
    if (elem == document.body) {
        clientHeight = window.innerHeight;
    }
 
    switch (event.keyCode) {
        case key.up:
            y = -options.arrowScroll;
            break;
        case key.down:
            y = options.arrowScroll;
            break;         
        case key.spacebar: // (+ shift)
            shift = event.shiftKey ? 1 : -1;
            y = -shift * clientHeight * 0.9;
            break;
        case key.pageup:
            y = -clientHeight * 0.9;
            break;
        case key.pagedown:
            y = clientHeight * 0.9;
            break;
        case key.home:
            y = -elem.scrollTop;
            break;
        case key.end:
            var damt = elem.scrollHeight - elem.scrollTop - clientHeight;
            y = (damt > 0) ? damt+10 : 0;
            break;
        case key.left:
            x = -options.arrowScroll;
            break;
        case key.right:
            x = options.arrowScroll;
            break;            
        default:
            return true; // a key we don't care about
    }
 
    scrollArray(elem, x, y);
    event.preventDefault();
    scheduleClearCache();
}
 
/**
 * Mousedown event only for updating activeElement
 */
function mousedown(event) {
    activeElement = event.target;
}
 
 
/***********************************************
 * OVERFLOW
 ***********************************************/
 
var uniqueID = (function () {
    var i = 0;
    return function (el) {
        return el.uniqueID || (el.uniqueID = i++);
    };
})();
 
var cache = {}; // cleared out after a scrolling session
var clearCacheTimer;
 
//setInterval(function () { cache = {}; }, 10 * 1000);
 
function scheduleClearCache() {
    clearTimeout(clearCacheTimer);
    clearCacheTimer = setInterval(function () { cache = {}; }, 1*1000);
}
 
function setCache(elems, overflowing) {
    for (var i = elems.length; i--;)
        cache[uniqueID(elems[i])] = overflowing;
    return overflowing;
}
 
//  (body)                (root)
//         | hidden | visible | scroll |  auto  |
// hidden  |   no   |    no   |   YES  |   YES  |
// visible |   no   |   YES   |   YES  |   YES  |
// scroll  |   no   |   YES   |   YES  |   YES  |
// auto    |   no   |   YES   |   YES  |   YES  |
 
function overflowingAncestor(el) {
    var elems = [];
    var body = document.body;
    var rootScrollHeight = root.scrollHeight;
    do {
        var cached = cache[uniqueID(el)];
        if (cached) {
            return setCache(elems, cached);
        }
        elems.push(el);
        if (rootScrollHeight === el.scrollHeight) {
            var topOverflowsNotHidden = overflowNotHidden(root) && overflowNotHidden(body);
            var isOverflowCSS = topOverflowsNotHidden || overflowAutoOrScroll(root);
            if (isFrame && isContentOverflowing(root) || 
               !isFrame && isOverflowCSS) {
                return setCache(elems, getScrollRoot()); 
            }
        } else if (isContentOverflowing(el) && overflowAutoOrScroll(el)) {
            return setCache(elems, el);
        }
    } while (el = el.parentElement);
}
 
function isContentOverflowing(el) {
    return (el.clientHeight + 10 < el.scrollHeight);
}
 
// typically for <body> and <html>
function overflowNotHidden(el) {
    var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');
    return (overflow !== 'hidden');
}
 
// for all other elements
function overflowAutoOrScroll(el) {
    var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');
    return (overflow === 'scroll' || overflow === 'auto');
}
 
 
/***********************************************
 * HELPERS
 ***********************************************/
 
function addEvent(type, fn) {
    window.addEventListener(type, fn, false);
}
 
function removeEvent(type, fn) {
    window.removeEventListener(type, fn, false);  
}
 
function isNodeName(el, tag) {
    return (el.nodeName||'').toLowerCase() === tag.toLowerCase();
}
 
function directionCheck(x, y) {
    x = (x > 0) ? 1 : -1;
    y = (y > 0) ? 1 : -1;
    if (direction.x !== x || direction.y !== y) {
        direction.x = x;
        direction.y = y;
        que = [];
        lastScroll = 0;
    }
}
 
var deltaBufferTimer;
 
if (window.localStorage && localStorage.SS_deltaBuffer) {
    deltaBuffer = localStorage.SS_deltaBuffer.split(',');
}
 
function isTouchpad(deltaY) {
    if (!deltaY) return;
    if (!deltaBuffer.length) {
        deltaBuffer = [deltaY, deltaY, deltaY];
    }
    deltaY = Math.abs(deltaY);
    deltaBuffer.push(deltaY);
    deltaBuffer.shift();
    clearTimeout(deltaBufferTimer);
    deltaBufferTimer = setTimeout(function () {
        if (window.localStorage) {
            localStorage.SS_deltaBuffer = deltaBuffer.join(',');
        }
    }, 1000);
    return !allDeltasDivisableBy(120) && !allDeltasDivisableBy(100);
} 
 
function isDivisible(n, divisor) {
    return (Math.floor(n / divisor) == n / divisor);
}
 
function allDeltasDivisableBy(divisor) {
    return (isDivisible(deltaBuffer[0], divisor) &&
            isDivisible(deltaBuffer[1], divisor) &&
            isDivisible(deltaBuffer[2], divisor));
}
 
function isInsideYoutubeVideo(event) {
    var elem = event.target;
    var isControl = false;
    if (document.URL.indexOf ('www.youtube.com/watch') != -1) {
        do {
            isControl = (elem.classList && 
                         elem.classList.contains('html5-video-controls'));
            if (isControl) break;
        } while (elem = elem.parentNode);
    }
    return isControl;
}

var requestFrameSmoothScroll = (function () {
      return (window.requestAnimationFrame       || 
//
//              window.webkitRequestAnimationFrame || 
//              window.mozRequestAnimationFrame    ||
              function (callback, element, delay) {
                 window.setTimeout(callback, delay || (1000/60));
             });
})();
 
var MutationObserver = (window.MutationObserver || 
                        window.WebKitMutationObserver ||
                        window.MozMutationObserver);  
 
var getScrollRoot = (function() {
  var SCROLL_ROOT;
  return function() {
    if (!SCROLL_ROOT) {
      var dummy = document.createElement('div');
      dummy.style.cssText = 'height:10000px;width:1px;';
      document.body.appendChild(dummy);
      var bodyScrollTop  = document.body.scrollTop;
      var docElScrollTop = document.documentElement.scrollTop;
      window.scrollBy(0, 1);
      if (document.body.scrollTop != bodyScrollTop)
        (SCROLL_ROOT = document.body);
      else 
        (SCROLL_ROOT = document.documentElement);
      window.scrollBy(0, -1);
      document.body.removeChild(dummy);
    }
    return SCROLL_ROOT;
  };
})();
 
 
/***********************************************
 * PULSE (by Michael Herf)
 ***********************************************/
 
/**
 * Viscous fluid with a pulse for part and decay for the rest.
 * - Applies a fixed force over an interval (a damped acceleration), and
 * - Lets the exponential bleed away the velocity over a longer interval
 * - Michael Herf, http://stereopsis.com/stopping/
 */
function pulse_(x) {
    var val, start, expx;
    // test
    x = x * options.pulseScale;
    if (x < 1) { // acceleartion
        val = x - (1 - Math.exp(-x));
    } else {     // tail
        // the previous animation ended here:
        start = Math.exp(-1);
        // simple viscous drag
        x -= 1;
        expx = 1 - Math.exp(-x);
        val = start + (expx * (1 - start));
    }
    return val * options.pulseNormalize;
}
 
function pulse(x) {
    if (x >= 1) return 1;
    if (x <= 0) return 0;
 
    if (options.pulseNormalize == 1) {
        options.pulseNormalize /= pulse_(1);
    }
    return pulse_(x);
}
 
var wheelEvent;
if ('onwheel' in document.createElement('div'))
    wheelEvent = 'wheel';
else if ('onmousewheel' in document.createElement('div'))
    wheelEvent = 'mousewheel';
 
if (wheelEvent) {
    addEvent(wheelEvent, wheel);
    addEvent('mousedown', mousedown);
    addEvent('load', init);
}
 
}(opt));

/**
 * smooth-scroll fork
 * @desc This API is different to  the other smooth-scroll. This API is
 * responsible for the panning of the viewport when clicking on internal links.
 * @author Kieren Evans
 * @see  @link {https://github.com/kierenevans/smooth-scroll}
 * @license GNU
 * This API has been heavily customized by Julien Etienne, and is not
 * applicable for redistribution.
 */

/*jslint browser: true */
(function(window, document, options, prefix, triangle) {
    "use strict";


    var transitionName = prefix('transition'),
        animationDuration = prefix('animationDuration');


    function getOffsetTop(el) {
        if (!el) {
            return 0;
        }

        var yOffset = el.offsetTop,
            parent = el.offsetParent;

        yOffset += getOffsetTop(parent);

        return yOffset;
    }

    function getScrollTop(scrollable) {
        return scrollable.scrollTop || document.body.scrollTop || document.documentElement.scrollTop;
    }

    function scrollTo(scrollable, coords, millisecondsToTake, callback) {
        var currentY = getScrollTop(scrollable),
            diffY = coords.y - currentY,
            startTimestamp = null;

        if (coords.y === currentY || typeof scrollable.scrollTo !== 'function') {
            return;
        }

        function doScroll(currentTimestamp) {
            if (startTimestamp === null) {
                startTimestamp = currentTimestamp;
            }

            var progress = currentTimestamp - startTimestamp,
                fractionDone = (progress / millisecondsToTake),
                pointOnSineWave = Math.sin(fractionDone * Math.PI / 2);
            scrollable.scrollTo(0, currentY + (diffY * pointOnSineWave));

            if (progress < millisecondsToTake) {
                requestAnimationFrame(doScroll);
            } else {
                // Ensure we're at our destination
                scrollable.scrollTo(coords.x, coords.y);
                callback();
            }
        }

        requestAnimationFrame(doScroll);
    }


    function smoothScroll(e, scrollSpeedMs, callback) { // no smooth scroll class to ignore links
        if (e.target.className === 'no-ss') {
            return;
        }

        var source = e,
            targetHref = source.hash,
            target = null;

        if (!source || !targetHref) {
            return;
        }

        targetHref = targetHref.substring(1);
        target = document.getElementById(targetHref);
        if (!target) {
            return;
        }

        scrollTo(window, {
            x: 0,
            y: getOffsetTop(target)
        }, scrollSpeedMs, callback);
    }

    function visibility(callback, event, fadeVal, fadeSpeedVal) {
        function callbackToDelay() {
            callback(event);
        }
        for (var i = 0; i < images.length; i++) {
            //fade.to(images[i], fadeSpeedVal, fadeVal);
            images[i].style[transitionName] = 'opacity ' + fadeSpeedVal + 's linear';
            images[i].style.opacity = fadeVal;
            if (i === images.length - 1 && callback) {
                delay(callbackToDelay, fadeSpeedVal * 1000);
            }
        }
    }

    function scrollToLink(e) {
        smoothScroll(e, options.linkScrollSpeed, function() {
            visibility(function() {
                tri.style[animationDuration] = '4s';

                triangle.setAttribute('fill', 'black');
            }, e, 1, options.fadeInSpeed);
        });
    }

    function randomColor() {
        var colors = ['#FA3442', '#4EEB00', '#1A5DED'];
        var rand = Math.floor(Math.random() * colors.length);
        return colors[rand];
    }


    // Uses target's hash for scroll
    clicktap(document, function(e) {
        var speed, eventTarget, isOpera = false,
            target;


        if (window.opera && opera.version() < 15) {
            target = 'logo-holder';

        } else {
            target = 'equilateral';
            if(e.target.parentNode.getAttribute('href') === '#top' || e.target.hash === '#top'){
                 e.preventDefault();
            }
        }

        e.stopPropagation();
        if (e.target.hash && e.target.hash !== '#top' || e.target.id === target ) {
            e.preventDefault();

            if (e.target.hash === '#top' || e.target.id === target) {
                tri.style[animationDuration] = '0.4s';
                triangle.setAttribute('fill', randomColor());
                speed = options.fadeOutSpeed;
            } else {
                tri.style[animationDuration] = '4s';
                triangle.setAttribute('fill', 'black');
                speed = 0;
            }

            if (e.target.id === target) {
                if (window.opera && opera.version() < 15) {
                    eventTarget = e.target.parentNode;
                } else {
                    eventTarget = e.target.parentNode.parentNode.parentNode;
                }


            } else {
                eventTarget = e.target;
            }

            visibility(scrollToLink, eventTarget, 0, speed);
        }

        if (e.target.id === 'location') {
            e.target.innerHTML = mail;
        }

    }, false);

}(window, document, opt, detectCSS, equilateral));

function buildSVGSchematics(crosses) {

  var lines, line1, line2;

  function svgSchematics(count) {
    var parentsHeight = parseInt(window.getComputedStyle(crosses[count]
        .parentNode, null).getPropertyValue("height"), 10) - 33,
      parentsWidth = parseInt(window.getComputedStyle(crosses[count]
        .parentNode, null).getPropertyValue("width"), 10);

    //Get line 
    lines = crosses[count].getElementsByTagName('line');

    line1 = lines[0];
    line1.setAttribute('x2', parentsWidth);
    line1.setAttribute('y2', parentsHeight);

    line2 = lines[1];
    line2.setAttribute('y1', parentsHeight);
    line2.setAttribute('x2', parentsWidth);

    crosses[count].setAttribute('height', parentsHeight);
    crosses[count].setAttribute('width', parentsWidth);

    crosses[count].setAttribute('viewBox', [0, 0, parentsWidth, parentsHeight]
      .join(','));

    crosses[count].setAttribute('preserveAspectRatio', 'xMidYMin');
  }

  for (var i = 0; i < crosses.length; i++) {
    svgSchematics(i);
  }
}

/**
 * @copyright Julien Etienne 2015
 */

(function(root, linkParent, pageTop) {

  var linkToTop = linkParent.children[0];

  function setupExperiments() {
    var experiment;
    document.addEventListener('mouseover', playExperiment, false);
    document.addEventListener('mouseout', stopExperiment, false);

    function playExperiment(e) {
      experiment = e.target.getAttribute('data-experiment');
      if (experiment) {
        e.target.style.opacity = 1;
        e.target.parentNode.style.backgroundImage = 'none';
        switchState[experiment](true);
      }
    }

    function stopExperiment(e) {
      experiment = e.target.getAttribute('data-experiment');
      if (experiment) {
        switchState[experiment](false);
      }
    }
  }



  function setLogoSizeAndPosition(element, size) {
    var realWidth = window.innerWidth;
    var realHeight = window.innerHeight;
    var logoSize, mgVal;

    size = 100 / size;
    logoSize = realWidth < realHeight ? realWidth : realHeight;

    mgVal = (logoSize / 768) * 16 + 'px ';
    element.style.padding = '0';
  }


  function setLogoSize(logoElement, factor) {
    var logoSize,
      logoHolder = logoElement.parentNode,
      screenArea = (screen.width * screen.height) / 1000,
      windowArea = (window.innerWidth * window.innerHeight) / 1000,
      mobileArea = 304.704,
      isMobile = screen.width <= 736 || screen.height <= 736 ?
      true : false;
    //
    if (screenArea <= mobileArea && isMobile) {
      logoSize = parseInt(windowArea / (factor / 6), 10);
      //  alert('windowARea: ' + windowArea);
    } else {
      logoSize = windowArea / factor;
      logoSize = logoSize < 55 ? 55 : parseInt(logoSize, 10);
      // alert(logoSize);
    }

    linkToTop.style.width = logoSize;
    linkToTop.style.height = logoSize;
  }




  window.onload = function() {
    buildSVGSchematics(svgSchematics);
    setLogoSize(logo, opt.logoSize);
    setupExperiments();
applicationCacheControl();
    if (screen.width >= 1024 || screen.width === undefined) {
      caretToEndOfLine(get('#', 'editable'));
    } else {
      pageTop.removeAttribute("contenteditable");
      setLogoSizeAndPosition(linkToTop, 3);
    }
  };


  resizilla.call(window, function() {
    buildSVGSchematics(svgSchematics);
    var screenWidth = screen.width < screen.height ?
      screen.width : screen.height;
    if (screenWidth > 736) {
      setLogoSize(logo, opt.logoSize);
    }
  }, 250, false);


  scrollNavigator(linkParent, root, detectCSS);
  postPrintRendering();

}(window, topArrow, header));


function applicationCacheControl() {
  // Check if a new cache is available on page load.
window.addEventListener('load', function(e) {

  window.applicationCache.addEventListener('updateready', function(e) {
    if (window.applicationCache.status == window.applicationCache.UPDATEREADY) {
      // Browser downloaded a new app cache.
      if (confirm('A new version of this site is available. Load it?')) {
        window.location.reload();
      }
    } else {
      // Manifest didn't changed. Nothing new to server.
    }
  }, false);

}, false);
}

/**
 * @copyright Julien Etienne 2015
 */
function scrollNavigator(navigator, root, prefix) {
  var transformName = prefix('transform'),
    arrow = navigator.children[0],
    corner = 'translate3d(0px, 0px, 0px)',
    midDimensions = [root.innerWidth / 2,
      root.innerHeight / 2
    ],
    vendors = ['webkit', 'moz'];
  console.log(navigator);

  setInitArrow.apply(null, midDimensions);

  setTimeout(
    function() {
      root.onscroll = function(e) {
        getScrollPosition.apply(null, midDimensions);
      };
    }, 1000);

  function setInitArrow(middleWidth, middleHeight) {
    arrow.style[transformName] = 'translate3d(-' + middleWidth + 'px, -' + middleHeight + 'px, 0)';
  }

  function revertToCorner(event) {
    // Need a get computed prefix
    if (arrow.style[transformName] !== corner) {
      navigator.style.zIndex = '-10';
    }
  }

  function getScrollPosition(middleWidth, middleHeight) {
    if (root.scrollY < screen.height) {
      navigator.style.opacity = 0;

      // Translate to center of window
      setInitArrow.call(null, middleWidth, middleHeight);

      arrow.addEventListener(prefixTransitionEnd(arrow), revertToCorner, false);

    } else {
      navigator.style.opacity = 0.7;
      navigator.style.zIndex = '10';

      arrow.style[transformName] = corner;

    }

  }
  getScrollPosition.apply(null, midDimensions);
}

function delay(callback, duration) {
    var startTime = 0,
        terminate = false;

    function loop(timestamp) {
        if (!startTime) {
            startTime = timestamp;
        }

        if (timestamp > startTime + duration && !terminate) {
            if (callback) callback();
            terminate = true;
        } else {
            requestAnimationFrame(loop);
        }
    }

    requestAnimationFrame(loop);
}

/**
 * @Author Barney Carroll 
 * @see  {@Link https://gist.github.com/barneycarroll/1096784}
 */
function detectCSS(prop){
    var prop = prop.replace(/-(\w)/g,function(s,g){
            return g.toUpperCase();
        }), 
        pre  = ',Moz,Ms,O,Webkit'.split(',');

    for (var i = 0; i < pre.length; ++i){
        if(i==1)
            prop = prop.slice(0,1).toUpperCase() + prop.slice(1);

        if(pre[i] + prop in document.documentElement.style)
            return pre[i] + prop;
    }

    return false; 
}


/**
 * Creates an equalateral triangle inside a given SVG parent node.
 * @Author Julien Etienne - 2015
 * @param  {Number} sideLength     - Length of side
 * @param  {Array} centerPosition  - central position the of triangle.
 * @param  {Object} parentNode     - The parentNode of the new triangle.
 * @return {Object}                - The polygon element.
 */
function equilateral(sideLength, centerPosition, parentNode) {
    var points,
        pi = 3.141592653589793238462643383, // more accuracy
        ns = 'http://www.w3.org/2000/svg',
        cen = centerPosition,
        halfSide = sideLength / 2,
        polygon = document.createElementNS(ns, 'polygon'),

        // Inner innerHypotenuse angle = 120, hyp = half side. Cos 120 * adjacent 
        innerHypotenuse = halfSide * (1 / Math.cos(30 * pi / 180)),

        // SqRt(Hyp^2 - Adj^2) pythagoras
        innerOpposite = halfSide * (1 / Math.tan(60 * pi / 180)),

        leftVertex = [],
        rightVertex = [],
        topVertex = [];

    leftVertex[0] = cen[0] - halfSide;
    leftVertex[1] = cen[1] + innerOpposite;

    rightVertex[0] = cen[0] + halfSide;
    rightVertex[1] = cen[1] + innerOpposite;

    topVertex[0] = cen[0];
    topVertex[1] = cen[1] - innerHypotenuse;

    points = topVertex[0] + ',' + topVertex[1] +
        ' ' + rightVertex[0] + ',' + rightVertex[1] +
        ' ' + leftVertex[0] + ',' + leftVertex[1];

    parentNode.appendChild(polygon);
    polygon.setAttribute('points', points);
    polygon.setAttribute('id', 'equilateral');

    return polygon;
}

/**
 * Gets the DOM element, index is optional
 * @param  {String} type    Selector type
 * @param  {String} element Selector reference
 * @param  {Number} index   Collection index.
 * @return {Object}         node | HTMLCollection.
 */
function get(type, element, index) {
  var elementReference, htmlObject,
    hasIndex = typeof index == 'number';

  // Check type 
  switch (type) {
    case '#' || 'id':
      elementReference = 'getElementById';
      break;
    case '.' || 'className':
      elementReference = 'getElementsByClassName';
      break;
    case 'tag' || 'tagName':
      elementReference = 'getElementsByTagName';
      break;
    case 'name':
      elementReference = 'getElementsByName';
      break;
    default:
      return;
  }

  // Check element exist
  if (element === 'body') {
    htmlObject = document.getElementsByTagName('body')[0] ||
      document.body;
    return htmlObject;
  } else if (!element) {
    return;
  }

  // Return node or collection of nodes
  if (!hasIndex) {
    htmlObject = document[elementReference](element);
  } else if (hasIndex && (elementReference === '#' ||
      elementReference === 'id')) {
    return;
  } else {
    htmlObject = document[elementReference](element)[index];
  }
  return htmlObject;
}

function caretToEndOfLine(el) {
  el.focus();
  if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
    var range = document.createRange();
    range.selectNodeContents(el);
    range.collapse(false);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (typeof document.body.createTextRange != "undefined") {
    var textRange = document.body.createTextRange();
    textRange.moveToElementText(el);
    textRange.collapse(false);
    textRange.select();
  }
}

  function postPrintRendering() {
    var prompt = true;
    var beforePrint = function() {
      if (prompt === true) {

        alert('Because images load on view, you may need to close this print prompt and quickly scroll to each image to ensure a good print/ pdf.');
        window.scrollTo(0, 0);
      }
    };
    var afterPrint = function() {
      if (prompt === true) {
        prompt = false;
      }
    };

    if (window.matchMedia) {
      var mediaQueryList = window.matchMedia('print');
      mediaQueryList.addListener(function(mql) {
        if (mql.matches) {
          beforePrint();
        } else {
          afterPrint();
        }
      });
    }

  }

/**
 * @copyright Julien Etienne 2015
 */
/**
 * Gets the prefixed transition end value fast, without creating a dummy object
 * @param  {Object} dummyElement - Any DOM element, preferably the subject.
 * @return {String} -  Returns the first supported transitionEnd string.
 */
function prefixTransitionEnd(dummyElement) {
    var transitionEnd = ['transitionend', 'oTransitionEnd', 'transitionend', 'webkitTransitionEnd'],
        transitions = ['transition', 'OTransition', 'MozTransition', 'WebkitTransition'],
        i = 0;
    for (; i < transitions.length; i++) {
        if (dummyElement.style[transitions[i]] !== undefined) {
            return transitionEnd[i];
        }
    }
}

/**
 * @copyright Julien Etienne 2015
 */

/**
 * @author Julien Etienne
 * Sets the style of an element with the appropriate browser prefix.
 * @param  {Object} styleObject       - Style detials.
 * @param  {Object} styleObject.el    - The element to apply the style to.
 * @param  {String} styleObject.style - The style that may require a prefix.
 * @param  {String|Number} styleObject.value - The value to be applied.
 */
function stylePrefix(styleObject) {
    var element = styleObject.el,
        cssStyle = styleObject.style,
        value = styleObject.value;

    if (!element && !cssStyle && !value) {
        return;
    }

    var vendors = ['ms', 'o', 'moz', 'webkit'],
        cssStyleCap = cssStyle.charAt(0).toUpperCase() + cssStyle.substring(1);
    if (!element.style[cssStyle]) {
        vendors.filter(function(vendor) {
            if (element.style[vendor + cssStyleCap] !== undefined) {
                element.style[vendor + cssStyleCap] = value;
            }
        });
    } else {
        element.style[cssStyle] = value;
    }
}

/**
 * End of main script.
 */
}());

/**
 * Examples
 */

(function (root) {
/*
 * More fruity circle BS, enjoy ;-) 
*/
    // Options
    var opt = {
        count: 32,
        min: 0.15,
        max: 0.6,
        maxVel: 12, // Set this to 1
        opacity: 0.5, // For mobile
        filter: "difference" // multiply | exclusion
    };

    
    
    var canvas = document.getElementById('smarties'),
        c = canvas.getContext('2d'),
        space = [canvas.width, canvas.height],
        cProps = [0, 0].concat(space),
        rad = 2 * Math.PI,
        rand,
        collision = {};
  
/** Quick dirty trick to faill back on something less
 *  cpu intensivie for mobile devices
 */
if(screen.width < 1023){
   c.globalAlpha = opt.opacity;
}else{
  c.globalCompositeOperation = opt.filter;
}
    // Make circles
    var circles = [];
    for (var i = 0; i < opt.count; i++) {
        rand = Math.random();
        rand = rand > opt.min ? rand : opt.min;
        var rDiff = (opt.max * 300) * rand;
        circles.push({
            x: ~~ ((space[0] * rand) - rDiff) || 25,
            y: ~~ ((space[1] * rand) - rDiff) || 25,
            r: ~~ (rDiff),
            color: ~~ (360 * rand),
            vx: ~~ (opt.maxVel * Math.random()),
            vy: ~~ (opt.maxVel * rand)
        });
    }


// Switch
var sw,count = 0;
root.switchState.smarties = function(state){
    if(!count){
        sw = state;
     requestAnimationFrame(paint);
     count = 1;
    }else{
       sw = state;
       count = 0;
    }
};
    // Paint circles
    function paint() {
        c.fillRect.apply(c, cProps);
        c.clearRect.apply(c, cProps);
        for (var i = 0; i < circles.length; i++) {
            //var rand  = (circles[i].color /3.6) /2;
            c.fillStyle = 'hsl(' + circles[i].color + ','+100+'%,'+50+'%)';
            c.beginPath();
            c.arc(circles[i].x, circles[i].y, circles[i].r, 0, rad, false);
            c.fill();

            // Collision logic
            collision.right = circles[i].x + circles[i].r > space[0];
            collision.left = circles[i].x - circles[i].r < 0;
            collision.floor = circles[i].y + circles[i].r > space[1];
            collision.ceiling = circles[i].y - circles[i].r < 0;

            // Turn the other cheek 
            collision.left || collision.right ? circles[i].vx *= -1 : null;
            collision.floor || collision.ceiling ? circles[i].vy *= -1 : null;

            circles[i].x += circles[i].vx; // horizontal force 
            circles[i].y += circles[i].vy; // vertical force 
        }
        if(sw)
            requestAnimationFrame(paint);
    }

  


}(window));

